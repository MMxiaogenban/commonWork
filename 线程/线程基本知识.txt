java并发编程必懂知识点解析(多线程并发编程)

1.并发编程三要素
原子性,有序性,可见性
原子性：一个操作或多个操作要么全部执行完成且执行过程不被中断，要么就不执行。

可见性：当多个线程同时访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

有序性：程序执行的顺序按照代码的先后顺序执行。

对于单线程，在执行代码时jvm会进行指令重排序，处理器为了提高效率，可以对输入代码进行优化，
它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证保存最终执行结果和代码顺序执行的结果是一致的。

Java语言对原子性、可见性、有序性的保证
1、原子性

在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断，要么执行，要么不执行。

X=10;  //原子性（简单的读取、将数字赋值给变量）

Y = x;  //变量之间的相互赋值，不是原子操作

X++;  //对变量进行计算操作

X = x+1;

语句2实际包括两个操作，它先要去读取x的值，再将y值写入，两个操作分开是原子性的。合在一起就不是原子性的。

语句3、4:x++  x=x+1包括3个操作：读取x的值，x+1，将x写入

注：可以通过 synchronized和Lock实现原子性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。

 

2、可见性

Java提供了volatile关键字保证可见性。

当一个共享变量被volatile修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，
当其他线程需要读取时，它会去内存中读取新值。Synchronized和Lock也可以保证可见性，
因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中，

 

3、有序性

在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述volatile关键字）。
另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，
相当于是让线程顺序执行同步代码，自然就保证了有序性。

Java内存模型：每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行
，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，
这个通常也称为happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，
那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

指令重排序：java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，
那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。

指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，
使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。

下面就来具体介绍下happens-before原则（先行发生原则）：

程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作

锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作

volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。如果一个线程先去写一个变量，
然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。

传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。

线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作

线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、
Thread.isAlive()的返回值手段检测到线程已经终止执行

2. 线程的五大状态

对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

创建状态

当用 new 操作符创建一个线程的时候

就绪状态

调用 start 方法，处于就绪状态的线程并不一定马上就会执行 run 方法，还需要等待CPU的调度

运行状态

CPU 开始调度线程，并开始执行 run 方法

阻塞状态

线程的执行过程中由于一些原因进入阻塞状态

比如：调用 sleep 方法、尝试去得到一个锁等等

死亡状态

run 方法执行完 或者 执行过程中遇到了一个异常

3.悲观锁与乐观锁
悲观锁 ：每次操作都会加锁，会造成线程阻塞。

乐观锁 ：每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。


4.线程之间的协作
4.1 wait/notify/notifyAll

这一组是 Object 类的方法

需要注意的是：这三个方法都必须在同步的范围内调用

wait

阻塞当前线程，直到 notify 或者 notifyAll 来唤醒

wait有三种方式的调用wait()必要要由 notify 或者 notifyAll 来唤醒wait(longtimeout)在指定时间内，
如果没有notify或notifAll方法的唤醒，也会自动唤醒。wait(longtimeout,longnanos)本质上还是调用一个
参数的方法

notify

只能唤醒一个处于 wait 的线程

notifyAll

唤醒全部处于 wait 的线程

4.2 sleep/yield/join

这一组是 Thread 类的方法

sleep

让当前线程暂停指定时间，只是让出CPU的使用权，并不释放锁

yield

暂停当前线程的执行，也就是当前CPU的使用权，让其他线程有机会执行，不能指定时间。
会让当前线程从运行状态转变为就绪状态，此方法在生产环境中很少会使用到
join

等待调用 join 方法的线程执行结束，才执行后面的代码

其调用一定要在 start 方法之后（看源码可知）

使用场景：当父线程需要等待子线程执行结束才执行后面内容或者需要某个子线程的执行结果会用到 join 方法

5.valitate 关键字
5.1 定义

java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。
Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，
java线程内存模型确保所有线程看到这个变量的值是一致的。

valitate是轻量级的synchronized，不会引起线程上下文的切换和调度，执行开销更小。

5.2 原理

1. 使用volitate修饰的变量在汇编阶段，会多出一条lock前缀指令

2. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；
即在执行到内存屏障这句指令时，在它前面的操作已经全部完成

3. 它会强制将对缓存的修改操作立即写入主存

4. 如果是写操作，它会导致其他CPU里缓存了该内存地址的数据无效

5.3 作用
内存可见性

多线程操作的时候，一个线程修改了一个变量的值 ，其他线程能立即看到修改后的值
防止重排序

即程序的执行顺序按照代码的顺序执行（处理器为了提高代码的执行效率可能会对代码进行重排序）

并不能保证操作的原子性
6. synchronized 关键字
确保线程互斥的访问同步代码

6.1 定义

synchronized 是JVM实现的一种锁，其中锁的获取和释放分别是

monitorenter 和 monitorexit 指令，该锁在实现上分为了偏向锁、轻量级锁和重量级锁，其中偏向锁在 java1.6 是默认开启的，
轻量级锁在多线程竞争的情况下会膨胀成重量级锁，有关锁的数据都保存在对象头中
6.2 原理

加了 synchronized 关键字的代码段，生成的字节码文件会多出 monitorenter 和 monitorexit 两条指令
（利用javap -verbose 字节码文件可看到关，

加了 synchronized 关键字的方法，生成的字节码文件中会多一个 ACC_SYNCHRONIZED 标志位，当方法调用时，
调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，
获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。
其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。
6.4 缺点

会让没有得到锁的资源进入Block状态，争夺到资源之后又转为Running状态，这个过程涉及到操作系统用户模式和内核模式的切换，
代价比较高。Java1.6为 synchronized 做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，
但是在最终转变为重量级锁之后，性能仍然较低。

7. CAS
AtomicBoolean，AtomicInteger，AtomicLong以及 Lock 相关类等底层就是用 CAS实现的，
在一定程度上性能比 synchronized 更高。

7.1 什么是CAS

CAS全称是Compare And Swap，即比较替换，是实现并发应用到的一种技术。操作包含三个操作数 —— 内存位置（V）、
预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。
否则，处理器不做任何操作。

7.2 为什么会有CAS

如果只是用 synchronized 来保证同步会存在以下问题

synchronized 是一种悲观锁，在使用上会造成一定的性能问题。在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和
调度延时，引起性能问题。一个线程持有锁会导致其它所有需要此锁的线程挂起。

























































